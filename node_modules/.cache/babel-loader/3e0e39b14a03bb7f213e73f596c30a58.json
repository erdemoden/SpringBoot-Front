{"ast":null,"code":"import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (function (routeConfigs) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n  const order = config.order || Object.keys(routeConfigs);\n  const getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  const {\n    initialRouteParams\n  } = config;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  const initialRouteIndex = order.indexOf(initialRouteName);\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\".concat(initialRouteName, \"'.\") + \"Should be one of \".concat(order.map(n => \"\\\"\".concat(n, \"\\\"\")).join(', ')));\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params,\n        ...params\n      };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams = routeName === initialRouteName ? initialRouteParams : null; // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return { ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        ...(params ? {\n          params\n        } : {})\n      };\n    }\n\n    return {\n      key: routeName,\n      routeName,\n      ...(params ? {\n        params\n      } : {})\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (backBehavior !== 'history' || prevState && nextState && nextState.index === prevState.index) {\n        return nextState;\n      }\n\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n\n        nextRouteKeyHistory.pop();\n      }\n\n      return { ...nextState,\n        routeKeyHistory: nextRouteKeyHistory\n      };\n    }\n\n    let nextState = possibleNextState;\n\n    if (prevState && possibleNextState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = { ...possibleNextState,\n        routes: nextRoutes\n      };\n    }\n\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex\n    };\n\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState\n      } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const {\n          params\n        } = action;\n\n        if (params) {\n          state.routes = state.routes.map(route => ({ ...route,\n            params: { ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName ? initialRouteParams : null)\n            }\n          }));\n        }\n      }\n\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        const {\n          params\n        } = action;\n        const index = state.routes.findIndex(route => route.routeName === action.routeName);\n\n        if (index === -1) {\n          throw new Error(\"There is no route named '\".concat(action.routeName, \"' in the navigator with the key '\").concat(action.key, \"'.\\n\") + \"Must be one of: \".concat(state.routes.map(route => \"'\".concat(route.routeName, \"'\")).join(',')));\n        }\n\n        return getNextState(action, prevState, { ...state,\n          routes: params ? state.routes.map((route, i) => i === index ? { ...route,\n            params: { ...route.params,\n              ...params\n            }\n          } : route) : state.routes,\n          index\n        });\n      } // Let the current child handle it\n\n\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, { ...state,\n            routes\n          });\n        }\n      } // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n\n\n      const isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n          const routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(action.action, childState);\n\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = { ...newChildState,\n              params: { ...(newChildState.params || {}),\n                ...action.params\n              }\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = { ...state,\n              routes,\n              index: activeChildIndex\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n\n        if (lastRoute) {\n          const params = { ...lastRoute.params,\n            ...action.params\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = { ...lastRoute,\n            params\n          };\n          return getNextState(action, prevState, { ...state,\n            routes\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, { ...state,\n          index: activeChildIndex\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state\n        };\n      }\n\n      const isActionBackOrPop = action.type === NavigationActions.BACK || action.type === StackActions.POP || action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren = !isActionBackOrPop || action.type === NavigationActions.BACK && action.key != null; // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n\n          if (i === index) {\n            return false;\n          }\n\n          let childState = routes[i];\n\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n\n          if (!childState) {\n            index = i;\n            return true;\n          }\n\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n\n          return false;\n        }); // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, { ...state,\n            index,\n            routes\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \".concat(state.index, \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\"));\n      const childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});","map":{"version":3,"mappings":"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","names":["invariant","getScreenForRouteName","createConfigGetter","NavigationActions","SwitchActions","StackActions","validateRouteConfigMap","createPathParser","defaultActionCreators","routeConfigs","config","order","Object","keys","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","hasOwnProperty","initialRouteIndex","indexOf","Error","map","n","join","childRouters","forEach","routeName","screen","router","getParamsForRoute","params","routeConfig","getPathAndParamsForRoute","getActionForPathAndParams","resetChildRoute","initialParams","childRouter","childAction","init","getStateForAction","key","getNextState","action","prevState","possibleNextState","updateNextStateHistory","nextState","index","nextRouteKeyHistory","routeKeyHistory","type","NAVIGATE","keyToAdd","routes","filter","k","push","BACK","pop","prevRouteName","nextRoutes","getInitialState","initialState","initialKey","getActionCreators","route","stateKey","inputState","state","activeChildIndex","INIT","JUMP_TO","findIndex","i","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","max","length","routeKey","didNavigate","find","childId","childState","newChildState","childStateUpdate","SET_PARAMS","lastRoute","isActionBackOrPop","POP","POP_TO_TOP","sendActionToInactiveChildren","preserveFocus","getComponentForState","getComponentForRouteName","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"sources":["/Users/erdemoden/Desktop/React-js/blog-app/node_modules/@react-navigation/core/lib/module/routers/SwitchRouter.js"],"sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const { initialRouteParams } = config;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map((n) => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach((routeName) => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : null;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        ...(params ? { params } : {}),\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      ...(params ? { params } : {}),\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (\n        backBehavior !== 'history' ||\n        (prevState && nextState && nextState.index === prevState.index)\n      ) {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter((k) => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      possibleNextState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n    };\n\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map((route) => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      if (\n        action.type === SwitchActions.JUMP_TO &&\n        (action.key == null || action.key === state.key)\n      ) {\n        const { params } = action;\n        const index = state.routes.findIndex(\n          (route) => route.routeName === action.routeName\n        );\n\n        if (index === -1) {\n          throw new Error(\n            `There is no route named '${action.routeName}' in the navigator with the key '${action.key}'.\\n` +\n              `Must be one of: ${state.routes\n                .map((route) => `'${route.routeName}'`)\n                .join(',')}`\n          );\n        }\n\n        return getNextState(action, prevState, {\n          ...state,\n          routes: params\n            ? state.routes.map((route, i) =>\n                i === index\n                  ? {\n                      ...route,\n                      params: {\n                        ...route.params,\n                        ...params,\n                      },\n                    }\n                  : route\n              )\n            : state.routes,\n          index,\n        });\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find((route) => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      const isActionBackOrPop =\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP ||\n        action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren =\n        !isActionBackOrPop ||\n        (action.type === NavigationActions.BACK && action.key != null);\n\n      // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n          if (i === index) {\n            return false;\n          }\n          let childState = routes[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            index = i;\n            return true;\n          }\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n          return false;\n        });\n\n        // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, {\n            ...state,\n            index,\n            routes,\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}