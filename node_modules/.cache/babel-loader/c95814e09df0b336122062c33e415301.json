{"ast":null,"code":"import * as NavigationActions from '../NavigationActions';\nimport * as StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return action.type === NavigationActions.NAVIGATE || action.type === StackActions.PUSH;\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (function (routeConfigs) {\n  let stackConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs); // Loop through routes and find child routers\n\n  routeNames.forEach(routeName => {\n    // We're not using `getScreenForRouteName` here to preserve the lazy loading\n    // behaviour of routes. This means that routes with child routers must be\n    // defined using a component directly or with an object with a screen prop.\n    const routeConfig = routeConfigs[routeName];\n    const screen = routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n  const {\n    initialRouteParams\n  } = stackConfig;\n  const getCustomActionCreators = stackConfig.getCustomActionCreators || defaultActionCreators;\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName]; // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {}; // The router is null for normal leaf routes\n\n      if (childRouter !== null) {\n        const childAction = action.action || NavigationActions.init({\n          params: action.params\n        });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [{\n          params: action.params,\n          ...childState,\n          key: action.key || generateKey(),\n          routeName: action.routeName\n        }]\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(NavigationActions.navigate({\n        routeName: initialRouteName,\n        params: initialRouteParams\n      }));\n    }\n\n    const params = (routeConfigs[initialRouteName].params || route.params || action.params || initialRouteParams) && { ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {})\n    };\n    const {\n      initialRouteKey\n    } = stackConfig;\n    route = { ...route,\n      ...(params ? {\n        params\n      } : {}),\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey()\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route]\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params,\n        ...action.params\n      };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const {\n        routeName\n      } = activeChildRoute;\n\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return { ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) => StackActions.pop({\n          n,\n          ...params\n        }),\n        popToTop: params => StackActions.popToTop(params),\n        push: (routeName, params, action) => StackActions.push({\n          routeName,\n          params,\n          action\n        }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey\n            });\n          }\n\n          invariant(typeof replaceWith === 'object', 'Must replaceWith an object or a string');\n          invariant(params == null, 'Params must not be provided to .replace() when specifying an object');\n          invariant(action == null, 'Child action must not be provided to .replace() when specifying an object');\n          invariant(newKey == null, 'Child action must not be provided to .replace() when specifying an object');\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) => StackActions.reset({\n          actions,\n          index: index == null ? actions.length - 1 : index,\n          key: navStateKey\n        }),\n        dismiss: () => NavigationActions.back({\n          key: navStateKey\n        })\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (!isResetToRootStack(action) && action.type !== NavigationActions.NAVIGATE) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(action, activeChildRoute);\n\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(state, activeChildRoute.key, route, // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n            action.type === NavigationActions.SET_PARAMS);\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction = action.routeName === childRoute.routeName && action.action ? action.action : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(childAction, childRoute);\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(state, nextRouteState ? nextRouteState.key : childRoute.key, nextRouteState ? nextRouteState : childRoute);\n              return { ...newState,\n                isTransitioning: state.index !== newState.index ? action.immediate !== true : state.isTransitioning\n              };\n            }\n          }\n        }\n      } // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n\n\n      if (behavesLikePushAction(action) && childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n        invariant(action.type !== StackActions.PUSH || action.key == null, 'StackRouter does not support key on the push action'); // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n\n        const lastRouteIndex = state.routes.findIndex(r => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        }); // An instance of this route exists already and we're dealing with a navigate action\n\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          } // Remove the now unused routes at the tail of the routes array\n\n\n          const routes = state.routes.slice(0, lastRouteIndex + 1); // Apply params if provided, otherwise leave route identity intact\n\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = { ...route,\n              params: { ...route.params,\n                ...action.params\n              }\n            };\n          } // Return state with new index. Change isTransitioning only if index has changed\n\n\n          return { ...state,\n            isTransitioning: state.index !== lastRouteIndex ? action.immediate !== true : state.isTransitioning,\n            index: lastRouteIndex,\n            routes\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction = action.action || NavigationActions.init({\n            params: getParamsForRouteAndAction(action.routeName, action)\n          });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey()\n          };\n        }\n\n        return { ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true\n        };\n      } else if (action.type === StackActions.PUSH && childRouters[action.routeName] === undefined) {\n        // Return the state identity to bubble the action up\n        return state;\n      } // Handle navigation to other child routers that are not yet pushed\n\n\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(NavigationActions.init()); // Then check to see if the router handles our navigate action\n\n            const navigatedChildRoute = childRouter.getStateForAction(action, initChildRoute);\n            let routeToPush = null;\n\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n\n            if (routeToPush) {\n              const route = { ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey()\n              };\n              return { ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true\n              };\n            }\n          }\n        }\n      } // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n\n\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        } // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n\n\n        if (state.index > 0) {\n          return { ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]]\n          };\n        }\n\n        return state;\n      } // Handle replace action\n\n\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex; // If the key param is undefined, set the index to the last route in the stack\n\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex(r => r.key === action.key);\n        } // Only replace if the key matches one of our routes\n\n\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n\n          if (childRouter) {\n            const childAction = action.action || NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action)\n            });\n            childState = childRouter.getStateForAction(childAction);\n          }\n\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey()\n          };\n          return { ...state,\n            routes\n          };\n        }\n      } // Update transitioning state\n\n\n      if (action.type === StackActions.COMPLETE_TRANSITION && (action.key == null || action.key === state.key) && action.toChildKey === state.routes[state.index].key && state.isTransitioning) {\n        return { ...state,\n          isTransitioning: false\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n\n        if (lastRoute) {\n          const params = { ...lastRoute.params,\n            ...action.params\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = { ...lastRoute,\n            params\n          };\n          return { ...state,\n            routes\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key !== state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n\n        const newStackActions = action.actions;\n        return { ...state,\n          routes: newStackActions.map(newStackAction => {\n            const router = childRouters[newStackAction.routeName];\n            let childState = {};\n\n            if (router) {\n              const childAction = newStackAction.action || NavigationActions.init({\n                params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction)\n              });\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(newStackAction.routeName, newStackAction),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey()\n            };\n          }),\n          index: action.index\n        };\n      }\n\n      if (action.type === NavigationActions.BACK || action.type === StackActions.POP) {\n        const {\n          key,\n          n,\n          immediate,\n          prune\n        } = action;\n\n        if (action.type === StackActions.POP && prune === false && key) {\n          const index = state.routes.findIndex(r => r.key === key);\n\n          if (index > 0) {\n            const count = Math.max(index - (n !== null && n !== void 0 ? n : 1) + 1, 1);\n            const routes = state.routes.slice(0, count).concat(state.routes.slice(index + 1));\n\n            if (routes.length) {\n              return { ...state,\n                routes,\n                index: routes.length - 1,\n                isTransitioning: immediate !== true\n              };\n            }\n          }\n        } else {\n          let backRouteIndex = state.index;\n\n          if (action.type === StackActions.POP && n != null) {\n            // determine the index to go back *from*. In this case, n=1 means to go\n            // back from state.index, as if it were a normal \"BACK\" action\n            backRouteIndex = Math.max(1, state.index - n + 1);\n          } else if (key) {\n            const backRoute = state.routes.find(route => route.key === key);\n            backRouteIndex = state.routes.indexOf(backRoute);\n          }\n\n          if (backRouteIndex > 0) {\n            return { ...state,\n              routes: state.routes.slice(0, backRouteIndex),\n              index: backRouteIndex - 1,\n              isTransitioning: immediate !== true\n            };\n          }\n        }\n      } // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1; // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        } // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n\n\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n\n        let childRouter = childRouters[childRoute.routeName];\n\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route, // People don't expect these actions to switch the active route\n            // TODO: We should switch to action.preserveFocus: true for drawer in future\n            action.preserveFocus || action.type.includes('DRAWER'));\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(routeConfigs, stackConfig.defaultNavigationOptions)\n  };\n});","map":{"version":3,"mappings":"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","names":["NavigationActions","StackActions","createConfigGetter","getScreenForRouteName","StateUtils","validateRouteConfigMap","invariant","generateKey","createPathParser","behavesLikePushAction","action","type","NAVIGATE","PUSH","defaultActionCreators","isResetToRootStack","RESET","key","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","routeConfig","screen","router","initialRouteParams","getCustomActionCreators","initialRouteName","initialChildRouter","getInitialState","route","childRouter","undefined","childState","childAction","init","params","getStateForAction","isTransitioning","index","routes","navigate","initialRouteKey","getParamsForRouteAndAction","getPathAndParamsForRoute","getActionForPathAndParams","getComponentForState","state","activeChildRoute","getComponentForRouteName","getActionCreators","navStateKey","pop","n","popToTop","push","replace","replaceWith","newKey","reset","actions","length","dismiss","back","activeChildRouter","replaceAt","SET_PARAMS","childRoute","slice","reverse","nextRouteState","newState","replaceAndPrune","immediate","lastRouteIndex","findIndex","r","childRouterNames","i","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","POP_TO_TOP","REPLACE","routeIndex","COMPLETE_TRANSITION","toChildKey","lastRoute","find","indexOf","newStackActions","map","newStackAction","BACK","POP","prune","count","Math","max","concat","backRouteIndex","backRoute","keyIndex","preserveFocus","includes","getPathAndParamsForState","path","getScreenOptions","defaultNavigationOptions"],"sources":["/Users/erdemoden/Desktop/React-js/blog-app/node_modules/@react-navigation/core/lib/module/routers/StackRouter.js"],"sourcesContent":["import * as NavigationActions from '../NavigationActions';\nimport * as StackActions from './StackActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport invariant from '../utils/invariant';\nimport { generateKey } from './KeyGenerator';\nimport { createPathParser } from './pathUtils';\n\nfunction behavesLikePushAction(action) {\n  return (\n    action.type === NavigationActions.NAVIGATE ||\n    action.type === StackActions.PUSH\n  );\n}\n\nconst defaultActionCreators = () => ({});\n\nfunction isResetToRootStack(action) {\n  return action.type === StackActions.RESET && action.key === null;\n}\n\nexport default (routeConfigs, stackConfig = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach((routeName) => {\n    // We're not using `getScreenForRouteName` here to preserve the lazy loading\n    // behaviour of routes. This means that routes with child routers must be\n    // defined using a component directly or with an object with a screen prop.\n    const routeConfig = routeConfigs[routeName];\n    const screen =\n      routeConfig && routeConfig.screen ? routeConfig.screen : routeConfig;\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n  const getCustomActionCreators =\n    stackConfig.getCustomActionCreators || defaultActionCreators;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n\n  function getInitialState(action) {\n    let route = {};\n    const childRouter = childRouters[action.routeName];\n\n    // This is a push-like action, and childRouter will be a router or null if we are responsible for this routeName\n    if (behavesLikePushAction(action) && childRouter !== undefined) {\n      let childState = {};\n      // The router is null for normal leaf routes\n      if (childRouter !== null) {\n        const childAction =\n          action.action || NavigationActions.init({ params: action.params });\n        childState = childRouter.getStateForAction(childAction);\n      }\n\n      return {\n        key: 'StackRouterRoot',\n        isTransitioning: false,\n        index: 0,\n        routes: [\n          {\n            params: action.params,\n            ...childState,\n            key: action.key || generateKey(),\n            routeName: action.routeName,\n          },\n        ],\n      };\n    }\n\n    if (initialChildRouter) {\n      route = initialChildRouter.getStateForAction(\n        NavigationActions.navigate({\n          routeName: initialRouteName,\n          params: initialRouteParams,\n        })\n      );\n    }\n    const params = (routeConfigs[initialRouteName].params ||\n      route.params ||\n      action.params ||\n      initialRouteParams) && {\n      ...(routeConfigs[initialRouteName].params || {}),\n      ...(route.params || {}),\n      ...(action.params || {}),\n      ...(initialRouteParams || {}),\n    };\n    const { initialRouteKey } = stackConfig;\n    route = {\n      ...route,\n      ...(params ? { params } : {}),\n      routeName: initialRouteName,\n      key: action.key || initialRouteKey || generateKey(),\n    };\n    return {\n      key: 'StackRouterRoot',\n      isTransitioning: false,\n      index: 0,\n      routes: [route],\n    };\n  }\n\n  function getParamsForRouteAndAction(routeName, action) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...action.params };\n    } else {\n      return action.params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, stackConfig);\n\n  return {\n    childRouters,\n\n    getComponentForState(state) {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getActionCreators(route, navStateKey) {\n      return {\n        ...getCustomActionCreators(route, navStateKey),\n        pop: (n, params) =>\n          StackActions.pop({\n            n,\n            ...params,\n          }),\n        popToTop: (params) => StackActions.popToTop(params),\n        push: (routeName, params, action) =>\n          StackActions.push({\n            routeName,\n            params,\n            action,\n          }),\n        replace: (replaceWith, params, action, newKey) => {\n          if (typeof replaceWith === 'string') {\n            return StackActions.replace({\n              routeName: replaceWith,\n              params,\n              action,\n              key: route.key,\n              newKey,\n            });\n          }\n          invariant(\n            typeof replaceWith === 'object',\n            'Must replaceWith an object or a string'\n          );\n          invariant(\n            params == null,\n            'Params must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            action == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          invariant(\n            newKey == null,\n            'Child action must not be provided to .replace() when specifying an object'\n          );\n          return StackActions.replace(replaceWith);\n        },\n        reset: (actions, index) =>\n          StackActions.reset({\n            actions,\n            index: index == null ? actions.length - 1 : index,\n            key: navStateKey,\n          }),\n        dismiss: () =>\n          NavigationActions.back({\n            key: navStateKey,\n          }),\n      };\n    },\n\n    getStateForAction(action, state) {\n      // Set up the initial state if needed\n      if (!state) {\n        return getInitialState(action);\n      }\n\n      const activeChildRoute = state.routes[state.index];\n\n      if (\n        !isResetToRootStack(action) &&\n        action.type !== NavigationActions.NAVIGATE\n      ) {\n        // Let the active child router handle the action\n        const activeChildRouter = childRouters[activeChildRoute.routeName];\n        if (activeChildRouter) {\n          const route = activeChildRouter.getStateForAction(\n            action,\n            activeChildRoute\n          );\n          if (route !== null && route !== activeChildRoute) {\n            return StateUtils.replaceAt(\n              state,\n              activeChildRoute.key,\n              route,\n              // the following tells replaceAt to NOT change the index to this route for the setParam action, because people don't expect param-setting actions to switch the active route\n              action.type === NavigationActions.SET_PARAMS\n            );\n          }\n        }\n      } else if (action.type === NavigationActions.NAVIGATE) {\n        // Traverse routes from the top of the stack to the bottom, so the\n        // active route has the first opportunity, then the one before it, etc.\n\n        for (let childRoute of state.routes.slice().reverse()) {\n          let childRouter = childRouters[childRoute.routeName];\n          let childAction =\n            action.routeName === childRoute.routeName && action.action\n              ? action.action\n              : action;\n\n          if (childRouter) {\n            const nextRouteState = childRouter.getStateForAction(\n              childAction,\n              childRoute\n            );\n\n            if (nextRouteState === null || nextRouteState !== childRoute) {\n              const newState = StateUtils.replaceAndPrune(\n                state,\n                nextRouteState ? nextRouteState.key : childRoute.key,\n                nextRouteState ? nextRouteState : childRoute\n              );\n              return {\n                ...newState,\n                isTransitioning:\n                  state.index !== newState.index\n                    ? action.immediate !== true\n                    : state.isTransitioning,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle push and navigate actions. This must happen after the focused\n      // child router has had a chance to handle the action.\n      if (\n        behavesLikePushAction(action) &&\n        childRouters[action.routeName] !== undefined // undefined means it's not a childRouter or a screen\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n\n        invariant(\n          action.type !== StackActions.PUSH || action.key == null,\n          'StackRouter does not support key on the push action'\n        );\n\n        // Before pushing a new route we first try to find one in the existing route stack\n        // More information on this: https://github.com/react-navigation/rfcs/blob/master/text/0004-less-pushy-navigate.md\n        const lastRouteIndex = state.routes.findIndex((r) => {\n          if (action.key) {\n            return r.key === action.key;\n          } else {\n            return r.routeName === action.routeName;\n          }\n        });\n\n        // An instance of this route exists already and we're dealing with a navigate action\n        if (action.type !== StackActions.PUSH && lastRouteIndex !== -1) {\n          // If index is unchanged and params are not being set, leave state identity intact\n          if (state.index === lastRouteIndex && !action.params) {\n            return null;\n          }\n\n          // Remove the now unused routes at the tail of the routes array\n          const routes = state.routes.slice(0, lastRouteIndex + 1);\n\n          // Apply params if provided, otherwise leave route identity intact\n          if (action.params) {\n            const route = state.routes[lastRouteIndex];\n            routes[lastRouteIndex] = {\n              ...route,\n              params: {\n                ...route.params,\n                ...action.params,\n              },\n            };\n          }\n          // Return state with new index. Change isTransitioning only if index has changed\n          return {\n            ...state,\n            isTransitioning:\n              state.index !== lastRouteIndex\n                ? action.immediate !== true\n                : state.isTransitioning,\n            index: lastRouteIndex,\n            routes,\n          };\n        }\n\n        if (childRouter) {\n          // Delegate to the child router with the given action, or init it\n          const childAction =\n            action.action ||\n            NavigationActions.init({\n              params: getParamsForRouteAndAction(action.routeName, action),\n            });\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // note(brentvatne): does it make sense to wipe out the params\n            // here? or even to add params at all? need more info about what\n            // this solves\n            ...childRouter.getStateForAction(childAction),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        } else {\n          // Create the route from scratch\n          route = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            routeName: action.routeName,\n            key: action.key || generateKey(),\n          };\n        }\n        return {\n          ...StateUtils.push(state, route),\n          isTransitioning: action.immediate !== true,\n        };\n      } else if (\n        action.type === StackActions.PUSH &&\n        childRouters[action.routeName] === undefined\n      ) {\n        // Return the state identity to bubble the action up\n        return state;\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (behavesLikePushAction(action)) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              const route = {\n                ...routeToPush,\n                routeName: childRouterName,\n                key: action.key || generateKey(),\n              };\n              return {\n                ...StateUtils.push(state, route),\n                isTransitioning: action.immediate !== true,\n              };\n            }\n          }\n        }\n      }\n\n      // Handle pop-to-top behavior. Make sure this happens after children have had a chance to handle the action, so that the inner stack pops to top first.\n      if (action.type === StackActions.POP_TO_TOP) {\n        // Refuse to handle pop to top if a key is given that doesn't correspond\n        // to this router\n        if (action.key && state.key !== action.key) {\n          return state;\n        }\n\n        // If we're already at the top, then we return the state with a new\n        // identity so that the action is handled by this router.\n        if (state.index > 0) {\n          return {\n            ...state,\n            isTransitioning: action.immediate !== true,\n            index: 0,\n            routes: [state.routes[0]],\n          };\n        }\n        return state;\n      }\n\n      // Handle replace action\n      if (action.type === StackActions.REPLACE) {\n        let routeIndex;\n\n        // If the key param is undefined, set the index to the last route in the stack\n        if (action.key === undefined && state.routes.length) {\n          routeIndex = state.routes.length - 1;\n        } else {\n          routeIndex = state.routes.findIndex((r) => r.key === action.key);\n        }\n\n        // Only replace if the key matches one of our routes\n        if (routeIndex !== -1) {\n          const childRouter = childRouters[action.routeName];\n          let childState = {};\n          if (childRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                params: getParamsForRouteAndAction(action.routeName, action),\n              });\n            childState = childRouter.getStateForAction(childAction);\n          }\n          const routes = [...state.routes];\n          routes[routeIndex] = {\n            params: getParamsForRouteAndAction(action.routeName, action),\n            // merge the child state in this order to allow params override\n            ...childState,\n            routeName: action.routeName,\n            key: action.newKey || generateKey(),\n          };\n          return { ...state, routes };\n        }\n      }\n\n      // Update transitioning state\n      if (\n        action.type === StackActions.COMPLETE_TRANSITION &&\n        (action.key == null || action.key === state.key) &&\n        action.toChildKey === state.routes[state.index].key &&\n        state.isTransitioning\n      ) {\n        return {\n          ...state,\n          isTransitioning: false,\n        };\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find((route) => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === StackActions.RESET) {\n        // Only handle reset actions that are unspecified or match this state key\n        if (action.key != null && action.key !== state.key) {\n          // Deliberately use != instead of !== so we can match null with\n          // undefined on either the state or the action\n          return state;\n        }\n        const newStackActions = action.actions;\n\n        return {\n          ...state,\n          routes: newStackActions.map((newStackAction) => {\n            const router = childRouters[newStackAction.routeName];\n\n            let childState = {};\n\n            if (router) {\n              const childAction =\n                newStackAction.action ||\n                NavigationActions.init({\n                  params: getParamsForRouteAndAction(\n                    newStackAction.routeName,\n                    newStackAction\n                  ),\n                });\n\n              childState = router.getStateForAction(childAction);\n            }\n\n            return {\n              params: getParamsForRouteAndAction(\n                newStackAction.routeName,\n                newStackAction\n              ),\n              ...childState,\n              routeName: newStackAction.routeName,\n              key: newStackAction.key || generateKey(),\n            };\n          }),\n          index: action.index,\n        };\n      }\n\n      if (\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP\n      ) {\n        const { key, n, immediate, prune } = action;\n\n        if (action.type === StackActions.POP && prune === false && key) {\n          const index = state.routes.findIndex((r) => r.key === key);\n\n          if (index > 0) {\n            const count = Math.max(index - (n ?? 1) + 1, 1);\n            const routes = state.routes\n              .slice(0, count)\n              .concat(state.routes.slice(index + 1));\n\n            if (routes.length) {\n              return {\n                ...state,\n                routes,\n                index: routes.length - 1,\n                isTransitioning: immediate !== true,\n              };\n            }\n          }\n        } else {\n          let backRouteIndex = state.index;\n\n          if (action.type === StackActions.POP && n != null) {\n            // determine the index to go back *from*. In this case, n=1 means to go\n            // back from state.index, as if it were a normal \"BACK\" action\n            backRouteIndex = Math.max(1, state.index - n + 1);\n          } else if (key) {\n            const backRoute = state.routes.find((route) => route.key === key);\n            backRouteIndex = state.routes.indexOf(backRoute);\n          }\n\n          if (backRouteIndex > 0) {\n            return {\n              ...state,\n              routes: state.routes.slice(0, backRouteIndex),\n              index: backRouteIndex - 1,\n              isTransitioning: immediate !== true,\n            };\n          }\n        }\n      }\n\n      // By this point in the router's state handling logic, we have handled the behavior of the active route, and handled any stack actions.\n      // If we haven't returned by now, we should allow non-active child routers to handle this action, and switch to that index if the child state (route) does change..\n\n      const keyIndex = action.key ? StateUtils.indexOf(state, action.key) : -1;\n\n      // Traverse routes from the top of the stack to the bottom, so the\n      // active route has the first opportunity, then the one before it, etc.\n      for (let childRoute of state.routes.slice().reverse()) {\n        if (childRoute.key === activeChildRoute.key) {\n          // skip over the active child because we let it attempt to handle the action earlier\n          continue;\n        }\n        // If a key is provided and in routes state then let's use that\n        // knowledge to skip extra getStateForAction calls on other child\n        // routers\n        if (keyIndex >= 0 && childRoute.key !== action.key) {\n          continue;\n        }\n        let childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n\n          if (route === null) {\n            return state;\n          } else if (route && route !== childRoute) {\n            return StateUtils.replaceAt(\n              state,\n              childRoute.key,\n              route,\n              // People don't expect these actions to switch the active route\n              // TODO: We should switch to action.preserveFocus: true for drawer in future\n              action.preserveFocus || action.type.includes('DRAWER')\n            );\n          }\n        }\n      }\n\n      return state;\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}